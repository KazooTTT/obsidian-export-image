/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/file-saver/dist/FileSaver.min.js
var require_FileSaver_min = __commonJS({
  "node_modules/file-saver/dist/FileSaver.min.js"(exports, module2) {
    (function(a, b) {
      if (typeof define == "function" && define.amd)
        define([], b);
      else if (typeof exports != "undefined")
        b();
      else {
        b(), a.FileSaver = { exports: {} }.exports;
      }
    })(exports, function() {
      "use strict";
      function b(a2, b2) {
        return typeof b2 == "undefined" ? b2 = { autoBom: false } : typeof b2 != "object" && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
      }
      function c(a2, b2, c2) {
        var d2 = new XMLHttpRequest();
        d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
          g(d2.response, b2, c2);
        }, d2.onerror = function() {
          console.error("could not download file");
        }, d2.send();
      }
      function d(a2) {
        var b2 = new XMLHttpRequest();
        b2.open("HEAD", a2, false);
        try {
          b2.send();
        } catch (a3) {
        }
        return 200 <= b2.status && 299 >= b2.status;
      }
      function e(a2) {
        try {
          a2.dispatchEvent(new MouseEvent("click"));
        } catch (c2) {
          var b2 = document.createEvent("MouseEvents");
          b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
        }
      }
      var f = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || (typeof window != "object" || window !== f ? function() {
      } : "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h) {
        var i = f.URL || f.webkitURL, j = document.createElement("a");
        g2 = g2 || b2.name || "download", j.download = g2, j.rel = "noopener", typeof b2 == "string" ? (j.href = b2, j.origin === location.origin ? e(j) : d(j.href) ? c(b2, g2, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b2), setTimeout(function() {
          i.revokeObjectURL(j.href);
        }, 4e4), setTimeout(function() {
          e(j);
        }, 0));
      } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h) {
        if (g2 = g2 || f2.name || "download", typeof f2 != "string")
          navigator.msSaveOrOpenBlob(b(f2, h), g2);
        else if (d(f2))
          c(f2, g2, h);
        else {
          var i = document.createElement("a");
          i.href = f2, i.target = "_blank", setTimeout(function() {
            e(i);
          });
        }
      } : function(b2, d2, e2, g2) {
        if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), typeof b2 == "string")
          return c(b2, d2, e2);
        var h = b2.type === "application/octet-stream", i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((j || h && i || a) && typeof FileReader != "undefined") {
          var k = new FileReader();
          k.onloadend = function() {
            var a2 = k.result;
            a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
          }, k.readAsDataURL(b2);
        } else {
          var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
          g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
            l.revokeObjectURL(m);
          }, 4e4);
        }
      });
      f.saveAs = g.saveAs = g, typeof module2 != "undefined" && (module2.exports = g);
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);

// ExportImagePlugin.ts
var import_obsidian2 = require("obsidian");
var import_file_saver = __toESM(require_FileSaver_min());

// constents.ts
var DEFAULT_SETTINGS = {
  width: "400"
};

// dom-to-image.js
var import_obsidian = require("obsidian");
var util = newUtil();
var inliner = newInliner();
var fontFaces = newFontFaces();
var images = newImages();
var defaultOptions = {
  imagePlaceholder: void 0,
  cacheBust: false
};
var domtoimage = {
  toSvg,
  toPng,
  toJpeg,
  toJpegWithClonedDom,
  toBlob,
  toPixelData,
  toBlobWithClonedDom,
  cloneNode,
  impl: {
    fontFaces,
    images,
    util,
    inliner,
    options: {}
  }
};
function toSvg(node, options) {
  options = options || {};
  copyOptions(options);
  return Promise.resolve(node).then(function(node2) {
    return cloneNode(node2, options.filter, true);
  }).then(embedFonts).then(inlineImages).then(applyOptions).then(function(clone) {
    return makeSvgDataUri(clone, options.width || util.width(node), options.height || util.height(node));
  });
  function applyOptions(clone) {
    if (options.bgcolor)
      clone.style.backgroundColor = options.bgcolor;
    if (options.width)
      clone.style.width = options.width + "px";
    if (options.height)
      clone.style.height = options.height + "px";
    if (options.style)
      Object.keys(options.style).forEach(function(property) {
        clone.style[property] = options.style[property];
      });
    return clone;
  }
}
function toSvgWithClonedDom(node, clone, options) {
  options = options || {};
  copyOptions(options);
  return Promise.resolve(clone).then(embedFonts).then(inlineImages).then(applyOptions).then(function(clone2) {
    return makeSvgDataUri(clone2, options.width * 2, options.height * 2);
  });
  function applyOptions(clone2) {
    if (options.bgcolor)
      clone2.style.backgroundColor = options.bgcolor;
    if (options.width)
      clone2.style.width = options.width + "px";
    if (options.height)
      clone2.style.height = options.height + "px";
    if (options.style)
      Object.keys(options.style).forEach(function(property) {
        clone2.style[property] = options.style[property];
      });
    return clone2;
  }
}
function toPixelData(node, options) {
  return draw(node, options || {}).then(function(canvas) {
    return canvas.getContext("2d").getImageData(0, 0, util.width(node), util.height(node)).data;
  });
}
function toPng(node, options) {
  return draw(node, options || {}).then(function(canvas) {
    return canvas.toDataURL();
  });
}
function toJpeg(node, options) {
  options = options || {};
  return draw(node, options).then(function(canvas) {
    return canvas.toDataURL("image/jpeg", options.quality || 1);
  });
}
function toJpegWithClonedDom(node, clone, options) {
  options = options || {};
  return drawWithClonedDom(node, clone, options).then(function(canvas) {
    return canvas.toDataURL("image/jpeg", options.quality || 1);
  });
}
function toBlob(node, options) {
  return draw(node, options || {}).then(function(canvas) {
    return util.canvasToBlob(canvas, options);
  });
}
function toBlobWithClonedDom(node, clone, options) {
  return drawWithClonedDom(node, clone, options || {}).then(function(canvas) {
    return util.canvasToBlob(canvas, options);
  });
}
function copyOptions(options) {
  if (typeof options.imagePlaceholder === "undefined") {
    domtoimage.impl.options.imagePlaceholder = defaultOptions.imagePlaceholder;
  } else {
    domtoimage.impl.options.imagePlaceholder = options.imagePlaceholder;
  }
  if (typeof options.cacheBust === "undefined") {
    domtoimage.impl.options.cacheBust = defaultOptions.cacheBust;
  } else {
    domtoimage.impl.options.cacheBust = options.cacheBust;
  }
}
function draw(domNode, options) {
  return toSvg(domNode, options).then(util.makeImage).then(util.delay(100)).then(function(image) {
    var canvas = newCanvas(domNode);
    canvas.getContext("2d").drawImage(image, 0, 0);
    return canvas;
  });
  function newCanvas(domNode2) {
    var canvas = document.createElement("canvas");
    canvas.width = options.width || util.width(domNode2);
    canvas.height = options.height || util.height(domNode2);
    if (options.bgcolor) {
      var ctx = canvas.getContext("2d");
      ctx.fillStyle = options.bgcolor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    return canvas;
  }
}
function drawWithClonedDom(domNode, clone, options) {
  return toSvgWithClonedDom(domNode, clone, options).then(util.makeImage).then(util.delay(100)).then(function(image) {
    var canvas = newCanvas();
    canvas.getContext("2d").drawImage(image, 0, 0, options.width * 2, options.height * 2);
    return canvas;
  });
  function newCanvas() {
    var canvas = document.createElement("canvas");
    canvas.width = options.width;
    canvas.height = options.height;
    if (options.bgcolor) {
      var ctx = canvas.getContext("2d");
      ctx.fillStyle = options.bgcolor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    return canvas;
  }
}
function cloneNode(node, filter, root) {
  if (!root && filter && !filter(node))
    return Promise.resolve();
  return Promise.resolve(node).then(makeNodeCopy).then(function(clone) {
    return cloneChildren(node, clone, filter);
  }).then(function(clone) {
    return processClone(node, clone);
  });
  function makeNodeCopy(node2) {
    if (node2 instanceof HTMLCanvasElement)
      return util.makeImage(node2.toDataURL());
    return node2.cloneNode(false);
  }
  function cloneChildren(original, clone, filter2) {
    var children = original.childNodes;
    if (children.length === 0)
      return Promise.resolve(clone);
    return cloneChildrenInOrder(clone, util.asArray(children), filter2).then(function() {
      return clone;
    });
    function cloneChildrenInOrder(parent, children2, filter3) {
      var done = Promise.resolve();
      children2.forEach(function(child) {
        done = done.then(function() {
          return cloneNode(child, filter3);
        }).then(function(childClone) {
          if (childClone)
            parent.appendChild(childClone);
        });
      });
      return done;
    }
  }
  function processClone(original, clone) {
    if (!(clone instanceof Element))
      return clone;
    return Promise.resolve().then(cloneStyle).then(clonePseudoElements).then(copyUserInput).then(fixSvg).then(function() {
      return clone;
    });
    function cloneStyle() {
      copyStyle(window.getComputedStyle(original), clone.style || {});
      function copyStyle(source, target) {
        if (source.cssText)
          target.cssText = source.cssText;
        else
          copyProperties(source, target);
        function copyProperties(source2, target2) {
          if (target2.setProperty) {
            util.asArray(source2).forEach(function(name) {
              target2.setProperty(name, source2.getPropertyValue(name), source2.getPropertyPriority(name));
            });
          }
        }
      }
    }
    function clonePseudoElements() {
      [":before", ":after"].forEach(function(element) {
        clonePseudoElement(element);
      });
      function clonePseudoElement(element) {
        var style = window.getComputedStyle(original, element);
        var content = style.getPropertyValue("content");
        if (content === "" || content === "none")
          return;
        var className = util.uid();
        clone.className = clone.className + " " + className;
        var styleElement = document.createElement("style");
        styleElement.appendChild(formatPseudoElementStyle(className, element, style));
        clone.appendChild(styleElement);
        function formatPseudoElementStyle(className2, element2, style2) {
          var selector = "." + className2 + ":" + element2;
          var cssText = style2.cssText ? formatCssText(style2) : formatCssProperties(style2);
          return document.createTextNode(selector + "{" + cssText + "}");
          function formatCssText(style3) {
            var content2 = style3.getPropertyValue("content");
            return style3.cssText + " content: " + content2 + ";";
          }
          function formatCssProperties(style3) {
            return util.asArray(style3).map(formatProperty).join("; ") + ";";
            function formatProperty(name) {
              return name + ": " + style3.getPropertyValue(name) + (style3.getPropertyPriority(name) ? " !important" : "");
            }
          }
        }
      }
    }
    function copyUserInput() {
      if (original instanceof HTMLTextAreaElement)
        clone.innerHTML = original.value;
      if (original instanceof HTMLInputElement)
        clone.setAttribute("value", original.value);
    }
    function fixSvg() {
      if (!(clone instanceof SVGElement))
        return;
      clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      if (!(clone instanceof SVGRectElement))
        return;
      ["width", "height"].forEach(function(attribute) {
        var value = clone.getAttribute(attribute);
        if (!value)
          return;
        clone.style.setProperty(attribute, value);
      });
    }
  }
}
function embedFonts(node) {
  return fontFaces.resolveAll().then(function(cssText) {
    var styleNode = document.createElement("style");
    node.appendChild(styleNode);
    styleNode.appendChild(document.createTextNode(cssText));
    return node;
  });
}
function inlineImages(node) {
  return images.inlineAll(node).then(function() {
    return node;
  });
}
function makeSvgDataUri(node, width, height) {
  return Promise.resolve(node).then(function(node2) {
    node2.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
    return new XMLSerializer().serializeToString(node2);
  }).then(util.escapeXhtml).then(function(xhtml) {
    return '<foreignObject x="0" y="0" width="100%" height="100%">' + xhtml + "</foreignObject>";
  }).then(function(foreignObject) {
    return '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '">' + foreignObject + "</svg>";
  }).then(function(svg) {
    return "data:image/svg+xml;charset=utf-8," + svg;
  });
}
function newUtil() {
  return {
    escape,
    parseExtension,
    mimeType,
    dataAsUrl,
    isDataUrl,
    canvasToBlob,
    resolveUrl,
    getAndEncode,
    uid: uid(),
    delay: delay2,
    asArray,
    escapeXhtml,
    makeImage,
    width,
    height
  };
  function mimes() {
    var WOFF = "application/font-woff";
    var JPEG = "image/jpeg";
    return {
      woff: WOFF,
      woff2: WOFF,
      ttf: "application/font-truetype",
      eot: "application/vnd.ms-fontobject",
      png: "image/png",
      jpg: JPEG,
      jpeg: JPEG,
      gif: "image/gif",
      tiff: "image/tiff",
      svg: "image/svg+xml"
    };
  }
  function parseExtension(url) {
    var match = /\.([^\.\/]*?)$/g.exec(url);
    if (match)
      return match[1];
    else
      return "";
  }
  function mimeType(url) {
    var extension = parseExtension(url).toLowerCase();
    return mimes()[extension] || "";
  }
  function isDataUrl(url) {
    return url.search(/^(data:)/) !== -1;
  }
  function toBlob2(canvas, options) {
    return new Promise(function(resolve) {
      var binaryString = window.atob(canvas.toDataURL("image/jpeg", options.quality || 1).split(",")[1]);
      var length = binaryString.length;
      var binaryArray = new Uint8Array(length);
      for (var i = 0; i < length; i++)
        binaryArray[i] = binaryString.charCodeAt(i);
      resolve(new Blob([binaryArray], {
        type: "image/jpeg"
      }));
    });
  }
  function canvasToBlob(canvas, options) {
    if (canvas.toBlob)
      return new Promise(function(resolve) {
        canvas.toBlob(resolve, "image/jpg", options.quality || 1);
      });
    return toBlob2(canvas, options);
  }
  function resolveUrl(url, baseUrl) {
    var doc = document.implementation.createHTMLDocument();
    var base = doc.createElement("base");
    doc.head.appendChild(base);
    var a = doc.createElement("a");
    doc.body.appendChild(a);
    base.href = baseUrl;
    a.href = url;
    return a.href;
  }
  function uid() {
    var index = 0;
    return function() {
      return "u" + fourRandomChars() + index++;
      function fourRandomChars() {
        return ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
      }
    };
  }
  function makeImage(uri) {
    return new Promise(function(resolve, reject) {
      var image = new Image();
      image.onload = function() {
        resolve(image);
      };
      image.onerror = resolve;
      image.src = uri;
    });
  }
  function getAndEncode(url) {
    var TIMEOUT = 3e4;
    if (domtoimage.impl.options.cacheBust) {
      url += (/\?/.test(url) ? "&" : "?") + new Date().getTime();
    }
    if (/^http/.test(url)) {
      return (0, import_obsidian.requestUrl)({
        url,
        method: "GET"
      }).then((data) => {
        let binary = "";
        const bytes = new Uint8Array(data.arrayBuffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
      }).catch((err) => {
        console.error("cannot fetch resource: " + url + ", error: " + err);
        return "";
      });
    }
    return new Promise(function(resolve) {
      var request = new XMLHttpRequest();
      request.onreadystatechange = done;
      request.ontimeout = timeout;
      request.responseType = "blob";
      request.timeout = TIMEOUT;
      request.open("GET", url, true);
      request.send();
      var placeholder;
      if (domtoimage.impl.options.imagePlaceholder) {
        var split = domtoimage.impl.options.imagePlaceholder.split(/,/);
        if (split && split[1]) {
          placeholder = split[1];
        }
      }
      function done() {
        if (request.readyState !== 4)
          return;
        if (request.status !== 200) {
          if (placeholder) {
            resolve(placeholder);
          } else {
            fail("cannot fetch resource: " + url + ", status: " + request.status);
          }
          return;
        }
        var encoder = new FileReader();
        encoder.onloadend = function() {
          var content = encoder.result.split(/,/)[1];
          resolve(content);
        };
        encoder.readAsDataURL(request.response);
      }
      function timeout() {
        if (placeholder) {
          resolve(placeholder);
        } else {
          fail("timeout of " + TIMEOUT + "ms occured while fetching resource: " + url);
        }
      }
      function fail(message) {
        console.error(message);
        resolve("");
      }
    });
  }
  function dataAsUrl(content, type) {
    return "data:" + type + ";base64," + content;
  }
  function escape(string) {
    return string.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  }
  function delay2(ms) {
    return function(arg) {
      return new Promise(function(resolve) {
        setTimeout(function() {
          resolve(arg);
        }, ms);
      });
    };
  }
  function asArray(arrayLike) {
    var array = [];
    var length = arrayLike.length;
    for (var i = 0; i < length; i++)
      array.push(arrayLike[i]);
    return array;
  }
  function escapeXhtml(string) {
    return string.replace(/#/g, "%23").replace(/\n/g, "%0A");
  }
  function width(node) {
    var leftBorder = px(node, "border-left-width");
    var rightBorder = px(node, "border-right-width");
    return node.scrollWidth + leftBorder + rightBorder;
  }
  function height(node) {
    var topBorder = px(node, "border-top-width");
    var bottomBorder = px(node, "border-bottom-width");
    return node.scrollHeight + topBorder + bottomBorder;
  }
  function px(node, styleProperty) {
    var value = window.getComputedStyle(node).getPropertyValue(styleProperty);
    return parseFloat(value.replace("px", ""));
  }
}
function newInliner() {
  var URL_REGEX = /url\(['"]?([^'"]+?)['"]?\)/g;
  return {
    inlineAll,
    shouldProcess,
    impl: {
      readUrls,
      inline
    }
  };
  function shouldProcess(string) {
    return string.search(URL_REGEX) !== -1;
  }
  function readUrls(string) {
    var result = [];
    var match;
    while ((match = URL_REGEX.exec(string)) !== null) {
      result.push(match[1]);
    }
    return result.filter(function(url) {
      return !util.isDataUrl(url);
    });
  }
  function inline(string, url, baseUrl, get) {
    return Promise.resolve(url).then(function(url2) {
      return baseUrl ? util.resolveUrl(url2, baseUrl) : url2;
    }).then(get || util.getAndEncode).then(function(data) {
      return util.dataAsUrl(data, util.mimeType(url));
    }).then(function(dataUrl) {
      return string.replace(urlAsRegex(url), "$1" + dataUrl + "$3");
    });
    function urlAsRegex(url2) {
      return new RegExp(`(url\\(['"]?)(` + util.escape(url2) + `)(['"]?\\))`, "g");
    }
  }
  function inlineAll(string, baseUrl, get) {
    if (nothingToInline())
      return Promise.resolve(string);
    return Promise.resolve(string).then(readUrls).then(function(urls) {
      var done = Promise.resolve(string);
      urls.forEach(function(url) {
        done = done.then(function(string2) {
          return inline(string2, url, baseUrl, get);
        });
      });
      return done;
    });
    function nothingToInline() {
      return !shouldProcess(string);
    }
  }
}
function newFontFaces() {
  return {
    resolveAll,
    impl: {
      readAll
    }
  };
  function resolveAll() {
    return readAll(document).then(function(webFonts) {
      return Promise.all(webFonts.map(function(webFont) {
        return webFont.resolve();
      }));
    }).then(function(cssStrings) {
      return cssStrings.join("\n");
    });
  }
  function readAll() {
    return Promise.resolve(util.asArray(document.styleSheets)).then(getCssRules).then(selectWebFontRules).then(function(rules) {
      return rules.map(newWebFont);
    });
    function selectWebFontRules(cssRules) {
      return cssRules.filter(function(rule) {
        return rule.type === CSSRule.FONT_FACE_RULE;
      }).filter(function(rule) {
        return inliner.shouldProcess(rule.style.getPropertyValue("src"));
      });
    }
    function getCssRules(styleSheets) {
      var cssRules = [];
      styleSheets.forEach(function(sheet) {
        try {
          util.asArray(sheet.cssRules || []).forEach(cssRules.push.bind(cssRules));
        } catch (e) {
          console.log("Error while reading CSS rules from " + sheet.href, e.toString());
        }
      });
      return cssRules;
    }
    function newWebFont(webFontRule) {
      return {
        resolve: function resolve() {
          var baseUrl = (webFontRule.parentStyleSheet || {}).href;
          return inliner.inlineAll(webFontRule.cssText, baseUrl);
        },
        src: function() {
          return webFontRule.style.getPropertyValue("src");
        }
      };
    }
  }
}
function newImages() {
  return {
    inlineAll,
    impl: {
      newImage
    }
  };
  function newImage(element) {
    return {
      inline
    };
    function inline(get) {
      if (util.isDataUrl(element.src))
        return Promise.resolve();
      return Promise.resolve(element.src).then(get || util.getAndEncode).then(function(data) {
        return util.dataAsUrl(data, util.mimeType(element.src));
      }).then(function(dataUrl) {
        return new Promise(function(resolve, reject) {
          element.onload = resolve;
          element.onerror = resolve;
          element.src = dataUrl;
        });
      });
    }
  }
  function inlineAll(node) {
    if (!(node instanceof Element))
      return Promise.resolve(node);
    return inlineBackground(node).then(function() {
      if (node instanceof HTMLImageElement)
        return newImage(node).inline();
      else
        return Promise.all(util.asArray(node.childNodes).map(function(child) {
          return inlineAll(child);
        }));
    });
    function inlineBackground(node2) {
      try {
        var background = node2.style.getPropertyValue("background");
      } catch (e) {
        return Promise.resolve(node2);
      }
      if (!background)
        return Promise.resolve(node2);
      return inliner.inlineAll(background).then(function(inlined) {
        node2.style.setProperty("background", inlined, node2.style.getPropertyPriority("background"));
      }).then(function() {
        return node2;
      });
    }
  }
}

// ExportImagePlugin.ts
function delay(ms) {
  return new Promise(function(resolve) {
    setTimeout(function() {
      resolve(void 0);
    }, ms);
  });
}
async function cloneDom(el, markdownView) {
  const container = el.parentElement;
  const scrollCache = container.scrollTop;
  container.scrollTo(0, 0);
  el.addClass("export-image-force-no-margin");
  await delay(40);
  const totalHeight = el.clientHeight;
  const screenHeight = markdownView.contentEl.clientHeight;
  let scrollIndex = 0;
  const clone = await cloneNode(el);
  const observer = new MutationObserver(async (records) => {
    for (let r of records) {
      for (let node of Array.from(r.addedNodes)) {
        clone.append(await cloneNode(node));
      }
    }
  });
  observer.observe(el, {
    childList: true
  });
  while (scrollIndex <= totalHeight - screenHeight) {
    scrollIndex += screenHeight;
    container.scrollTo(0, scrollIndex);
    await delay(40);
  }
  observer.disconnect();
  container.scrollTo(0, scrollCache);
  clone.addClass("export-image-clone");
  document.body.appendChild(clone);
  el.removeClass("export-image-force-no-margin");
  return clone;
}
var ExportImagePlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "export-to-image-zh",
      name: "Export to image",
      checkCallback: (checking) => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
        if ((markdownView == null ? void 0 : markdownView.getMode()) === "preview") {
          if (!checking) {
            (async () => {
              const el = markdownView.contentEl.find(".markdown-preview-section");
              const clone = await cloneDom(el, markdownView);
              const blob = await toBlobWithClonedDom(el, clone, {
                width: clone.clientWidth * 2,
                height: clone.clientHeight * 2,
                bgcolor: window.getComputedStyle(el.closest(".view-content")).backgroundColor,
                quality: 0.9,
                style: {
                  transform: "scale(2)",
                  transformOrigin: "top left"
                }
              });
              document.body.removeChild(clone);
              (0, import_file_saver.saveAs)(blob, `${markdownView.getDisplayText().replace(/\s+/g, "_")}.jpg`);
            })();
          }
          return true;
        }
      }
    });
    this.addCommand({
      id: "copy-as-image-zh",
      name: "Copy as image",
      checkCallback: (checking) => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
        if ((markdownView == null ? void 0 : markdownView.getMode()) === "preview") {
          if (!checking) {
            (async () => {
              const el = markdownView.contentEl.find(".markdown-preview-section");
              const clone = await cloneDom(el, markdownView);
              const blob = await toBlobWithClonedDom(el, clone, {
                width: clone.clientWidth * 2,
                height: clone.clientHeight * 2,
                bgcolor: window.getComputedStyle(el.closest(".view-content")).backgroundColor,
                quality: 0.9,
                style: {
                  transform: "scale(2)",
                  transformOrigin: "top left"
                }
              });
              document.body.removeChild(clone);
              const data = [
                new ClipboardItem({
                  [blob.type]: blob
                })
              ];
              await navigator.clipboard.write(data);
              new import_obsidian2.Notice("Copied!");
            })();
          }
          return true;
        }
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};

// main.ts
var main_default = ExportImagePlugin;
